syntax = "proto3";

package message.v1;

import "common/v1/types.proto";

// Message 是前端 ( 业务客户端 ) 和网关之间的通信消息。
message Message {
  // 由前端 ( 业务客户端 ) 生成，有 2 个作用:
  //  1.消息去重。
  //  2.对 message_id 进行 hash，选择消息队列分区从而保证消息有序性。
  //
  // message_id 需要由前端生成 ( 建议使用 ULID )
  //
  //  npm install ulid
  //  或
  //  yarn add ulid
  //
  //  import { ulid } from 'ulid'
  //
  //  const messageId = ulid()
  //
  //  // 也支持从时间戳生成
  //  const messageId = ulid(Date.now())
  string message_id = 1;

  // 目的地频道 ID ( 在网关用于获取目的地用户所在的 WebSocket )。
  string destination_id = 2;
  // 目的地频道类型 ( 单聊 / 群聊 )
  string destination_type = 3;

  // 消息类型。
  // 这里不使用 MessageType type 作为字段名是因为 type 在 go 里面是关键字。
  common.v1.CommandType cmd = 4;

  // body 的序列化类型。
  common.v1.SerializeType serialize_type = 5;

  // 消息体。
  bytes body = 6;
}

// AckPayload 是消息确认的载荷，包含消息的处理结果。
// 当 Message.cmd = COMMAND_TYPE_ACK 时，该消息会被序列化到 Message.body 中。
// 适用于上行消息和下行消息的 ACK 响应。
message AckPayload {
  // 消息处理是否成功。
  bool success = 1;

  // 错误信息（ 仅在 success = false 时有值 ）。
  string error_message = 2;

  // 服务端处理时间戳（毫秒）。
  int64 timestamp = 3;
}

// PushMessage 是由后端 ( 业务服务端 ) 主动向网关发送的消息。
// 通信方式为业务后端推送 PushMessage 到 Kafka 的指定 topic，由网关监听并消费。
// 网关收到 PushMessage 后，
// 会向前端发送 CommandType 为 COMMAND_TYPE_DOWNSTREAM 的 Message。
message PushMessage {
  // 同 Message 的 message_id ( 业务服务端 ) 生成。
  string message_id = 1;
  uint64 biz_id = 2;
  uint64 receiver_id = 3;

  // body 的序列化类型。
  common.v1.SerializeType serialize_type = 4;

  // 消息体。
  bytes body = 5;
}

// PushService 由网关提供给后端 ( 业务服务端 ) 调用。
// 用于以 kafka 通信外的方式主动向前端 ( 业务服务端 ) 推送消息。
//
// 前端消息 → 网关 → Kafka → 后端落库 → RPC调用网关 → 目标用户
service PushService {
  rpc Push(PushRequest) returns (PushResponse);
}

message PushRequest {
  PushMessage msg = 1;
}

message PushResponse {}
