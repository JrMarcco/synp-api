syntax = "proto3";

package message.v1;

import "common/v1/types.proto";

// Message 是前端 ( 业务客户端 ) 和网关之间的通信消息。
message Message {
  // 由前端 ( 业务客户端 ) 生成，有 2 个作用:
  //  1.消息去重。
  //  2.对 message_id 进行 hash，选择消息队列分区从而保证消息有序性。
  //
  // message_id 需要由前端生成 ( 建议使用 ULID )
  //
  //  npm install ulid
  //  或
  //  yarn add ulid
  //
  //  import { ulid } from 'ulid'
  //
  //  const messageId = ulid()
  //
  //  // 也支持从时间戳生成
  //  const messageId = ulid(Date.now())
  string message_id = 1;

  // 消息类型。
  // 这里不使用 MessageType type 作为字段名是因为 type 在 go 里面是关键字。
  common.v1.CommandType cmd = 2;

  // body 的序列化类型。
  common.v1.SerializeType serialize_type = 3;

  // 消息体。
  bytes body = 4;
}

// AckPayload 是消息确认的载荷，包含消息的处理结果。
// 当 Message.cmd = COMMAND_TYPE_ACK 时，该消息会被序列化到 Message.body 中。
// 适用于上行消息和下行消息的 ACK 响应。
message AckPayload {
  // 消息处理是否成功。
  bool success = 1;

  // 错误信息（ 仅在 success = false 时有值 ）。
  string error_message = 2;

  // 服务端处理时间戳（毫秒）。
  int64 timestamp = 3;
}

// PushMessage 是由后端 ( 业务服务端 ) 主动向网关发送的消息。
// 通信方式为业务后端推送 PushMessage 到 Kafka 的指定 topic，由网关监听并消费。
// 网关收到 PushMessage 后，
// 会向前端发送 CommandType 为 COMMAND_TYPE_DOWNSTREAM 的 Message。
message PushMessage {
  // 同 Message 的 message_id ( 业务服务端 ) 生成。
  string message_id = 1;
  uint64 biz_id = 2;
  uint64 receiver_id = 3;

  // body 的序列化类型。
  common.v1.SerializeType serialize_type = 4;

  // 消息体。
  bytes body = 5;
}

// PushService 由网关提供给后端 ( 业务服务端 ) 调用。
// 用于以 kafka 通信外的方式主动向前端 ( 业务服务端 ) 推送消息。
//
// 前端消息 → 网关 → Kafka → 后端落库 → RPC调用网关 → 目标用户
service PushService {
  rpc Push(PushRequest) returns (PushResponse);
  rpc BatchPush(BatchPushRequest) returns (BatchPushResponse);
}

message PushRequest {
  PushMessage message = 1;
  bool need_retry = 2;
}

enum PushStatus {
  PUSH_STATUS_UNSPECIFIED = 0;
  PUSH_STATUS_SUCCESS = 1; // 成功
  PUSH_STATUS_USER_OFFLINE = 2; // 用户离线
  PUSH_STATUS_RATE_LIMITED = 3; // 限流
  PUSH_STATUS_INVALID_MESSAGE = 4; // 消息格式错误
  PUSH_STATUS_INTERNAL_ERROR = 5; // 内部错误
}

message PushResponse {
  PushStatus status = 1;
  string error_message = 2;
}

message BatchPushRequest {
  repeated PushMessage messages = 1;
  // 预留字段。
  // 可选的回调地址 ( 用于结果通知 )。
  string callback_url = 2;
}

// BatchPushResponse 批量推送响应。
// 目前均为预留字段。
message BatchPushResponse {
  string task_id = 1;
  int32 accepted_count = 2;
  int32 rejected_count = 3;
}
