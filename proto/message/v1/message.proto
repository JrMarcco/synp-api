syntax = "proto3";

package message.v1;

import "common/v1/types.proto";

// Message 是前端 (业务客户端) 和网关之间的通信消息。
message Message {
  // 由前端 ( 业务客户端 ) 生成，有 2 个作用:
  //  1.消息去重；
  //  2.对 message_id 进行 hash，选择消息队列分区从而保证消息有序性。
  string message_id = 1;

  // 消息类型。
  // 这里不使用 MessageType type 作为字段名是因为 type 在 go 里面是关键字。
  common.v1.CommandType cmd = 2;

  // body 的序列化类型。
  common.v1.SerializeType serialize_type = 3;

  // 消息体。
  bytes body = 4;
}

// AckPayload 是消息确认的载荷，包含消息的处理结果。
// 当 Message.cmd = COMMAND_TYPE_ACK 时，该消息会被序列化到 Message.body 中。
// 适用于上行消息和下行消息的 ACK 响应。
message AckPayload {
  // 原始消息的 message_id，用于关联请求。
  string original_message_id = 1;

  // 消息处理是否成功。
  bool success = 2;

  // 错误信息（仅在 success = false 时有值）。
  string error_message = 3;

  // 服务端处理时间戳（毫秒）。
  int64 timestamp = 4;
}

// PushMessage 是由后端 ( 业务服务端 ) 主动向网关发送的消息。
// 通信方式为业务后端推送 PushMessage 到 Kafka 的指定 topic，由网关监听并消费。
// 网关收到 PushMessage 后，
// 会向前端发送 CommandType 为 COMMAND_TYPE_DOWNSTREAM 的 Message。
message PushMessage {
  // 同 Message 的 message_id ( 业务服务端 ) 生成。
  string message_id = 1;
  uint64 biz_id = 2;
  uint64 receiver_id = 3;

  // body 的序列化类型。
  common.v1.SerializeType serialize_type = 4;

  // 消息体。
  bytes body = 5;
}
